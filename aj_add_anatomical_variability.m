function [ph_anatomical, ph_noise, ph_var, ellipse_anatomical] = ...
    aj_add_anatomical_variability(ph, ellipse, jitter_range, jitter_factor, prenoise_level, sm_kern, noise_range, noise_level, noise_before_smoothing, plot_fig)
% aj_add_anatomical_variability Adds anatomical variability and noise to a 3D aj_create_pahntom_3d
% 
% INPUTS:
% ph           : Original phantom volume
% ellipse      : Original ellipsoid parameters (as generated by aj_shepplogan_3d)
% jitter_factor: Maximum random jitter for anatomical variability
% noise_level  : Variance of Gaussian noise to add to the image signal
% noise_before_smoothing : Boolean flag to apply noise before gaussian smooting
% plot_fig     : Boolean flag to plot resulting profiles or not
%
% OUTPUTS:
% ph_anatomical     : Phantom with anatomical variability
% ph_noise          : Phantom with noise
% ph_var            : Phantom with anatomical variability and noise
% ellipse_anatomical: Ellipsoid parameters with variability

%% Default parameters
if nargin < 5, plot_fig = false; end
if nargin < 4, noise_level = []; end
if nargin < 3, jitter_factor = []; end

%% Jitter factor
if isempty(jitter_factor) || jitter_factor < jitter_range(1) || jitter_factor > jitter_range(2)
    jitter_factor = mean(jitter_range); % default value = 0.05
    disp(['Jitter factor hors de la gamme recommandée, défini à la valeur par défaut de ', num2str(jitter_factor)]);
end

%% Noise level
if isempty(noise_level) || noise_level < noise_range(1) || noise_level > noise_range(2)
    noise_level = mean(noise_range);
    disp(['Niveau de bruit hors de la gamme recommandée, défini à la valeur par défaut de ', num2str(noise_level)]);
end

% image_std = std(ph(:));
% noise_range = [0.01 * image_std, 0.1 * image_std];
% 
% if isempty(noise_level) || noise_level < noise_range(1) || noise_level > noise_range(2)
%     noise_level = mean(noise_range); % Défaut à 5% de l'écart-type si en dehors de la gamme
%     disp(['Niveau de bruit hors de la gamme recommandée, défini à la valeur par défaut de ', num2str(noise_level)]);
% end

%% Adding anatomical variability to the original phatom
ellipse_anatomical = ellipse; % Make a copy of the original ellipse param

x_ellipse = 3; % laisser les 2ères ellipses constantes

nb_ellipse = size(ellipse);
subellipse = ellipse(x_ellipse:nb_ellipse(2), 2:10); % x_ellipse to 10th ellipses, 2nd to 10th parameters
subellipse_anatomical = subellipse; % Créer une copie pour appliquer les changements

for l = 1:size(subellipse, 1) % Parcours des ellipses (lignes)
    % Calculer la taille de l'ellipse (par exemple, la moyenne des dimensions)
    ellipse_size = mean(subellipse(l, 2:4)); % Supposons que les colonnes 2-4 contiennent les rayons

    % Ajuster le jitter en fonction de la taille de l'ellipse
    adjusted_jitter = jitter_factor * (ellipse_size / max(subellipse(:, 2:4), [], 'all'));

    for k = 1:size(subellipse, 2) % Parcours des paramètres (colonnes)
        if subellipse(l, k) == 0
            subellipse_anatomical(l, k) = adjusted_jitter * randn(1);  % Bruit gaussien centré sur 0
        else
            subellipse_anatomical(l, k) = subellipse(l, k) + ...
                (2 * randi([0, 1]) - 1) * adjusted_jitter * subellipse(l, k) * randn(1);
        end
    end
end

ellipse_anatomical(x_ellipse:nb_ellipse(2), 2:10) = subellipse_anatomical;

[ph_anatomical, ~] = aj_create_phantom_3d(ellipse_anatomical, size(ph, 1)); 
% resulting ellipse is the same than the input ellipse_anatomical

%% Apply noise before smoothing
if noise_before_smoothing
    ph_noisy_anat = ph_anatomical + prenoise_level * randn(size(ph_anatomical));
    ph_anatomical = ph_noisy_anat;
    
%     figure;
%     slice_num = round(size(ph_anatomical, 1) / 2);
%     min_val = min(ph_anatomical(:));
%     max_val = max(ph_anatomical(:));
%     imagesc(squeeze(ph_anatomical(:, :, slice_num)), [min_val, max_val]);
%     title('Original Phantom');
%     colormap gray;
%     axis image;
end

%% Apply Gaussian smoothing
wg = gausswin(sm_kern); % Créer le noyau gaussien
wg = wg / sum(wg); % Normaliser le noyau

% Appliquer le lissage en 3D
smoothed_ph = convn(ph_anatomical, reshape(wg, [length(wg), 1, 1]), 'same');
smoothed_ph = convn(smoothed_ph, reshape(wg, [1, length(wg), 1]), 'same');
smoothed_ph = convn(smoothed_ph, reshape(wg, [1, 1, length(wg)]), 'same');

% Remplacer ph_anatomical par l'image lissée
ph_anatomical = smoothed_ph;

%% Adding noise to the original phatom
ph_noise = ph + noise_level * randn(size(ph));

%% Adding anatomical variability and noise
ph_var = ph_anatomical + noise_level * randn(size(ph_anatomical));

%% Optionnel : Visualisation des résultats
if plot_fig
    figure;
    
    slice_num = round(size(ph, 1) / 2);
    
    % Trouver la valeur minimale et maximale globale
%     min_val = min([ph(:); ph_anatomical(:); ph_noise(:); ph_var(:)]);
%     max_val = max([ph(:); ph_anatomical(:); ph_noise(:); ph_var(:)]);
    % Trouver la valeur minimale et maximale de l'image originale
    min_val = min(ph(:));
    max_val = max(ph(:));

    % Tracer les sous-graphes avec une échelle de couleurs partagée
    subplot(2, 2, 1);
    imagesc(squeeze(ph(:, :, slice_num)), [min_val, max_val]);
    title('Original Phantom');
    colormap gray;
    axis image;

    subplot(2, 2, 2);
    imagesc(squeeze(ph_anatomical(:, :, slice_num)), [min_val, max_val]);
    title('Anatomical Variability');
    colormap gray;
    axis image;

    subplot(2, 2, 3);
    imagesc(squeeze(ph_noise(:, :, slice_num)), [min_val, max_val]);
    title('Noise');
    colormap gray;
    axis image;

    subplot(2, 2, 4);
    imagesc(squeeze(ph_var(:, :, slice_num)), [min_val, max_val]);
    title('Anatomical Variability + Noise');
    colormap gray;
    axis image;
end

end
